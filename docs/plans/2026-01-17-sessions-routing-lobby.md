# Sessions, Routing, and Lobby Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement persistent sessions using React Router and LocalStorage, and add a public lobby to browse active rooms.

**Architecture:**
- **Routing:** Use `react-router-dom` to manage application state via URL (`/` for lobby, `/room/:roomId` for game).
- **Persistence:** Store user identity (`userId`, `userName`) in `localStorage` to persist across reloads.
- **Lobby:** Fetch active rooms from the server (`GET /api/rooms`) and display them in the lobby.

**Tech Stack:** React, React Router, Socket.io, Tailwind CSS, LocalStorage.

---

### Task 1: Setup React Router in Main Entry

**Files:**
- Modify: `client/src/main.tsx`

**Step 1: Check if BrowserRouter is already used**
Read `client/src/main.tsx` to see current structure.

**Step 2: Wrap App in BrowserRouter**
Modify `client/src/main.tsx` to wrap `<App />` with `<BrowserRouter>`.

**Step 3: Verification**
Run the app and ensure it still loads without errors (it should just render App as before).

### Task 2: Implement Routing Structure in App.tsx

**Files:**
- Modify: `client/src/App.tsx`

**Step 1: Import Router components**
Import `Routes`, `Route`, `useNavigate`, `useParams`, `Navigate` from `react-router-dom`.

**Step 2: Define Routes**
Refactor `App` component to define routes:
- `/` -> `<LobbyRoute />` (New wrapper component or modified logic)
- `/room/:roomId` -> `<GameRoute />` (New wrapper component)

**Step 3: Refactor SynapseBoard logic**
Move the `isInRoom` logic to be driven by the route.
- If URL has `:roomId`, we are "in room".
- If URL is `/`, we are in lobby.

**Step 4: Implement GameRoute component**
Create a component that:
1. Reads `roomId` from params.
2. Checks `localStorage` for `synapse_user`.
3. If user exists, attempts to `join-room`.
4. If user missing, redirects to `/` with `?join=roomId` query param (or handles name entry).

**Step 5: Implement LobbyRoute component**
Renders `RoomManager`.

### Task 3: Implement Session Persistence

**Files:**
- Modify: `client/src/App.tsx` (or `GameRoute`)
- Modify: `client/src/components/RoomManager.tsx`

**Step 1: Save User on Join/Create**
In `RoomManager`, when user sets name and joins/creates:
- Save `{ userId, userName }` to `localStorage.getItem('synapse_user')`.
- Note: `userId` is currently generated by server. We might need to generate it on client or save it *after* connection.
- Better: When server sends `room-joined` or `room-created`, save the returned `userId` and `userName` to `localStorage`.

**Step 2: Auto-Join on Route Load**
In `GameRoute` (inside `App.tsx`):
- `useEffect` on mount.
- If `socket` connected and `roomId` present:
  - Check `localStorage`.
  - If found, emit `join-room` with saved identity.
  - If not found, show "Enter Name" UI (or redirect to lobby with intent).

### Task 4: Enhance RoomManager with Lobby List

**Files:**
- Modify: `client/src/components/RoomManager.tsx`

**Step 1: Add "Public Rooms" Fetch**
- Add `useEffect` to fetch `GET /api/rooms` on mount.
- Store in state `availableRooms`.

**Step 2: Render Room Grid**
- Add a section "Active Public Rooms".
- Map `availableRooms` to Cards showing:
  - Room ID
  - Player Count
  - "Join" button.

**Step 3: Handle Join Click**
- Clicking "Join" on a card sets the `roomId` state and switches to "Join" tab (or auto-fills).

### Task 5: Server-Side Lobby Support (Validation)

**Files:**
- Check: `server/index.js`

**Step 1: Verify API**
Ensure `GET /api/rooms` returns necessary data (id, userCount, hasPassword).
(It currently does).

**Step 2: Add Room Name? (Optional)**
Server currently doesn't store room names (just IDs). We'll stick to IDs for now.

### Execution Order

1.  **Modify `main.tsx`**: Add Router.
2.  **Refactor `App.tsx`**: Implement Routes and Session logic.
3.  **Update `RoomManager.tsx`**: Add Lobby UI and Fetch logic.
4.  **Verification**: Test flow: Create -> Reload -> Auto-rejoin. Test flow: Lobby -> Select Room -> Join.

